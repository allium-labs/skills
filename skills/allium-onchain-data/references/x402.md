# x402 Micropayments

Pay-per-call with USDC on Base. No API key needed.

**Requirements:** EVM wallet with USDC on Base

**Enabled Endpoints:**

| Endpoint | Price |
|----------|-------|
| `/api/v1/developer/prices` | $0.001 |

---

## Python Client

```python
# /// script
# requires-python = ">=3.10"
# dependencies = ["x402[evm]", "httpx"]
# ///

import base64
import httpx
from eth_account import Account
from eth_account.messages import encode_typed_data
from x402 import x402ClientSync, parse_payment_required
from x402.mechanisms.evm.exact import ExactEvmScheme

PRIVATE_KEY = "0x..."  # Store securely!
BASE_URL = "https://api.allium.so"

class Signer:
    def __init__(self, private_key: str):
        self._account = Account.from_key(private_key)

    @property
    def address(self) -> str:
        return self._account.address

    def sign_typed_data(self, domain, types, primary_type, message) -> bytes:
        domain_dict = {"name": domain.name, "version": domain.version,
                       "chainId": domain.chain_id, "verifyingContract": domain.verifying_contract}
        converted_types = {k: [{"name": f.name, "type": f.type} for f in v] for k, v in types.items()}
        full_message = {
            "types": {"EIP712Domain": [{"name": "name", "type": "string"}, {"name": "version", "type": "string"},
                      {"name": "chainId", "type": "uint256"}, {"name": "verifyingContract", "type": "address"}],
                      **converted_types},
            "primaryType": primary_type, "domain": domain_dict, "message": message
        }
        return self._account.sign_message(encode_typed_data(full_message=full_message)).signature

def create_client(private_key: str) -> x402ClientSync:
    client = x402ClientSync()
    client.register("eip155:8453", ExactEvmScheme(signer=Signer(private_key)))
    return client

def x402_request(client, http, method, url, **kwargs):
    headers = kwargs.pop("headers", {})
    headers["X-Prefer-Payment"] = "x402"
    response = http.request(method, url, headers=headers, **kwargs)
    if response.status_code == 402:
        payment = client.create_payment_payload(parse_payment_required(response.json()))
        headers["PAYMENT-SIGNATURE"] = base64.b64encode(payment.model_dump_json().encode()).decode()
        response = http.request(method, url, headers=headers, **kwargs)
    return response

# Usage
def get_price(token_address: str, chain: str):
    with httpx.Client(timeout=30.0) as http:
        return x402_request(create_client(PRIVATE_KEY), http, "POST",
            f"{BASE_URL}/api/v1/developer/prices",
            json=[{"token_address": token_address, "chain": chain}]).json()
```

---

## Flow

```
1. POST /prices with X-Prefer-Payment: x402
2. Receive 402 with payment requirements
3. Sign EIP-712 payment
4. Retry with PAYMENT-SIGNATURE header
5. Receive 200 with data
```

---

## Errors

| Status | Action |
|--------|--------|
| 402 | Sign and retry |
| 422 | Check parameters |
| 429 | Back off |
